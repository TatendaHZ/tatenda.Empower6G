/*
 * Npcf_PolicyAuthorization Service API
 * PCF Policy Authorization Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
 *
 * The version of the OpenAPI document: 1.2.0-alpha.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package autogen.pcf.api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import autogen.pcf.api.JSON;

/**
 * Represents 5GS-Level UE identities.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-30T14:53:51.866477499+03:00[Europe/Athens]")
public class UeIdentityInfo implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_GPSI = "gpsi";
  @SerializedName(SERIALIZED_NAME_GPSI)
  private String gpsi;

  public static final String SERIALIZED_NAME_PEI = "pei";
  @SerializedName(SERIALIZED_NAME_PEI)
  private String pei;

  public static final String SERIALIZED_NAME_SUPI = "supi";
  @SerializedName(SERIALIZED_NAME_SUPI)
  private String supi;

  public UeIdentityInfo() {
  }

  public UeIdentityInfo gpsi(String gpsi) {
    
    this.gpsi = gpsi;
    return this;
  }

   /**
   * String identifying a Gpsi shall contain either an External Id or an MSISDN. It shall be formatted as follows -External Identifier&#x3D; \&quot;extid-&lt;extid&gt;, where &lt;extid&gt; shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an External Identifier.
   * @return gpsi
  **/
  @jakarta.annotation.Nullable
  public String getGpsi() {
    return gpsi;
  }


  public void setGpsi(String gpsi) {
    this.gpsi = gpsi;
  }


  public UeIdentityInfo pei(String pei) {
    
    this.pei = pei;
    return this;
  }

   /**
   * String representing a Permanent Equipment Identifier that may contain - an IMEI or IMEISV, as specified in clause 6.2 of 3GPP TS 23.003; a MAC address for a 5G-RG or FN-RG via wireline access, with an indication that this address cannot be trusted for regulatory purpose if this address cannot be used as an Equipment Identifier of the FN-RG, as specified in clause 4.7.7 of 3GPP TS23.316. Examples are imei-012345678901234 or imeisv-0123456789012345.
   * @return pei
  **/
  @jakarta.annotation.Nullable
  public String getPei() {
    return pei;
  }


  public void setPei(String pei) {
    this.pei = pei;
  }


  public UeIdentityInfo supi(String supi) {
    
    this.supi = supi;
    return this;
  }

   /**
   * String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause 2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \&quot;imsi-&lt;imsi&gt;\&quot;, where &lt;imsi&gt; shall be formatted according to clause 2.2 of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \&quot;nai-&lt;nai&gt;, where &lt;nai&gt; shall be formatted according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \&quot;gci-&lt;gci&gt;\&quot;, where &lt;gci&gt; shall be formatted according to clause 28.15.2 of 3GPP TS 23.003.  - for a GLI \&quot;gli-&lt;gli&gt;\&quot;, where &lt;gli&gt; shall be formatted according to clause 28.16.2 of 3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall only contain characters allowed according to the \&quot;lower-with-hyphen\&quot; naming convention defined in 3GPP TS 29.501. 
   * @return supi
  **/
  @jakarta.annotation.Nullable
  public String getSupi() {
    return supi;
  }


  public void setSupi(String supi) {
    this.supi = supi;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the UeIdentityInfo instance itself
   */
  public UeIdentityInfo putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UeIdentityInfo ueIdentityInfo = (UeIdentityInfo) o;
    return Objects.equals(this.gpsi, ueIdentityInfo.gpsi) &&
        Objects.equals(this.pei, ueIdentityInfo.pei) &&
        Objects.equals(this.supi, ueIdentityInfo.supi)&&
        Objects.equals(this.additionalProperties, ueIdentityInfo.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(gpsi, pei, supi, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UeIdentityInfo {\n");
    sb.append("    gpsi: ").append(toIndentedString(gpsi)).append("\n");
    sb.append("    pei: ").append(toIndentedString(pei)).append("\n");
    sb.append("    supi: ").append(toIndentedString(supi)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to UeIdentityInfo
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UeIdentityInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UeIdentityInfo is not found in the empty JSON string", UeIdentityInfo.openapiRequiredFields.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("gpsi") != null && !jsonObj.get("gpsi").isJsonNull()) && !jsonObj.get("gpsi").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gpsi` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gpsi").toString()));
      }
      if ((jsonObj.get("pei") != null && !jsonObj.get("pei").isJsonNull()) && !jsonObj.get("pei").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pei` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pei").toString()));
      }
      if ((jsonObj.get("supi") != null && !jsonObj.get("supi").isJsonNull()) && !jsonObj.get("supi").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `supi` to be a primitive type in the JSON string but got `%s`", jsonObj.get("supi").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UeIdentityInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UeIdentityInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UeIdentityInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UeIdentityInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<UeIdentityInfo>() {
           @Override
           public void write(JsonWriter out, UeIdentityInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public UeIdentityInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             UeIdentityInfo instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of UeIdentityInfo given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of UeIdentityInfo
  * @throws IOException if the JSON string is invalid with respect to UeIdentityInfo
  */
  public static UeIdentityInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UeIdentityInfo.class);
  }

 /**
  * Convert an instance of UeIdentityInfo to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

