/*
 * Npcf_PolicyAuthorization Service API
 * PCF Policy Authorization Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
 *
 * The version of the OpenAPI document: 1.2.0-alpha.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package autogen.pcf.api.model;

import java.util.Objects;
import autogen.pcf.api.model.Ipv6Addr;
import autogen.pcf.api.model.Snssai;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.io.Serializable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import autogen.pcf.api.JSON;

/**
 * Indicates P-CSCF restoration.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-30T14:53:51.866477499+03:00[Europe/Athens]")
public class PcscfRestorationRequestData implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_DNN = "dnn";
  @SerializedName(SERIALIZED_NAME_DNN)
  private String dnn;

  public static final String SERIALIZED_NAME_IP_DOMAIN = "ipDomain";
  @SerializedName(SERIALIZED_NAME_IP_DOMAIN)
  private String ipDomain;

  public static final String SERIALIZED_NAME_SLICE_INFO = "sliceInfo";
  @SerializedName(SERIALIZED_NAME_SLICE_INFO)
  private Snssai sliceInfo;

  public static final String SERIALIZED_NAME_SUPI = "supi";
  @SerializedName(SERIALIZED_NAME_SUPI)
  private String supi;

  public static final String SERIALIZED_NAME_UE_IPV4 = "ueIpv4";
  @SerializedName(SERIALIZED_NAME_UE_IPV4)
  private String ueIpv4;

  public static final String SERIALIZED_NAME_UE_IPV6 = "ueIpv6";
  @SerializedName(SERIALIZED_NAME_UE_IPV6)
  private Ipv6Addr ueIpv6;

  public PcscfRestorationRequestData() {
  }

  public PcscfRestorationRequestData dnn(String dnn) {
    
    this.dnn = dnn;
    return this;
  }

   /**
   * String representing a Data Network as defined in clause 9A of 3GPP TS 23.003; it shall contain either a DNN Network Identifier, or a full DNN with both the Network Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots (e.g. \&quot;Label1.Label2.Label3\&quot;).
   * @return dnn
  **/
  @jakarta.annotation.Nullable
  public String getDnn() {
    return dnn;
  }


  public void setDnn(String dnn) {
    this.dnn = dnn;
  }


  public PcscfRestorationRequestData ipDomain(String ipDomain) {
    
    this.ipDomain = ipDomain;
    return this;
  }

   /**
   * Get ipDomain
   * @return ipDomain
  **/
  @jakarta.annotation.Nullable
  public String getIpDomain() {
    return ipDomain;
  }


  public void setIpDomain(String ipDomain) {
    this.ipDomain = ipDomain;
  }


  public PcscfRestorationRequestData sliceInfo(Snssai sliceInfo) {
    
    this.sliceInfo = sliceInfo;
    return this;
  }

   /**
   * Get sliceInfo
   * @return sliceInfo
  **/
  @jakarta.annotation.Nullable
  public Snssai getSliceInfo() {
    return sliceInfo;
  }


  public void setSliceInfo(Snssai sliceInfo) {
    this.sliceInfo = sliceInfo;
  }


  public PcscfRestorationRequestData supi(String supi) {
    
    this.supi = supi;
    return this;
  }

   /**
   * String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause 2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \&quot;imsi-&lt;imsi&gt;\&quot;, where &lt;imsi&gt; shall be formatted according to clause 2.2 of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \&quot;nai-&lt;nai&gt;, where &lt;nai&gt; shall be formatted according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \&quot;gci-&lt;gci&gt;\&quot;, where &lt;gci&gt; shall be formatted according to clause 28.15.2 of 3GPP TS 23.003.  - for a GLI \&quot;gli-&lt;gli&gt;\&quot;, where &lt;gli&gt; shall be formatted according to clause 28.16.2 of 3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall only contain characters allowed according to the \&quot;lower-with-hyphen\&quot; naming convention defined in 3GPP TS 29.501. 
   * @return supi
  **/
  @jakarta.annotation.Nullable
  public String getSupi() {
    return supi;
  }


  public void setSupi(String supi) {
    this.supi = supi;
  }


  public PcscfRestorationRequestData ueIpv4(String ueIpv4) {
    
    this.ueIpv4 = ueIpv4;
    return this;
  }

   /**
   * String identifying a IPv4 address formatted in the \&quot;dotted decimal\&quot; notation as defined in RFC 1166.
   * @return ueIpv4
  **/
  @jakarta.annotation.Nullable
  public String getUeIpv4() {
    return ueIpv4;
  }


  public void setUeIpv4(String ueIpv4) {
    this.ueIpv4 = ueIpv4;
  }


  public PcscfRestorationRequestData ueIpv6(Ipv6Addr ueIpv6) {
    
    this.ueIpv6 = ueIpv6;
    return this;
  }

   /**
   * Get ueIpv6
   * @return ueIpv6
  **/
  @jakarta.annotation.Nullable
  public Ipv6Addr getUeIpv6() {
    return ueIpv6;
  }


  public void setUeIpv6(Ipv6Addr ueIpv6) {
    this.ueIpv6 = ueIpv6;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the PcscfRestorationRequestData instance itself
   */
  public PcscfRestorationRequestData putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PcscfRestorationRequestData pcscfRestorationRequestData = (PcscfRestorationRequestData) o;
    return Objects.equals(this.dnn, pcscfRestorationRequestData.dnn) &&
        Objects.equals(this.ipDomain, pcscfRestorationRequestData.ipDomain) &&
        Objects.equals(this.sliceInfo, pcscfRestorationRequestData.sliceInfo) &&
        Objects.equals(this.supi, pcscfRestorationRequestData.supi) &&
        Objects.equals(this.ueIpv4, pcscfRestorationRequestData.ueIpv4) &&
        Objects.equals(this.ueIpv6, pcscfRestorationRequestData.ueIpv6)&&
        Objects.equals(this.additionalProperties, pcscfRestorationRequestData.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dnn, ipDomain, sliceInfo, supi, ueIpv4, ueIpv6, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PcscfRestorationRequestData {\n");
    sb.append("    dnn: ").append(toIndentedString(dnn)).append("\n");
    sb.append("    ipDomain: ").append(toIndentedString(ipDomain)).append("\n");
    sb.append("    sliceInfo: ").append(toIndentedString(sliceInfo)).append("\n");
    sb.append("    supi: ").append(toIndentedString(supi)).append("\n");
    sb.append("    ueIpv4: ").append(toIndentedString(ueIpv4)).append("\n");
    sb.append("    ueIpv6: ").append(toIndentedString(ueIpv6)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to PcscfRestorationRequestData
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PcscfRestorationRequestData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PcscfRestorationRequestData is not found in the empty JSON string", PcscfRestorationRequestData.openapiRequiredFields.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("dnn") != null && !jsonObj.get("dnn").isJsonNull()) && !jsonObj.get("dnn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dnn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dnn").toString()));
      }
      if ((jsonObj.get("ipDomain") != null && !jsonObj.get("ipDomain").isJsonNull()) && !jsonObj.get("ipDomain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipDomain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipDomain").toString()));
      }
      // validate the optional field `sliceInfo`
      if (jsonObj.get("sliceInfo") != null && !jsonObj.get("sliceInfo").isJsonNull()) {
        Snssai.validateJsonElement(jsonObj.get("sliceInfo"));
      }
      if ((jsonObj.get("supi") != null && !jsonObj.get("supi").isJsonNull()) && !jsonObj.get("supi").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `supi` to be a primitive type in the JSON string but got `%s`", jsonObj.get("supi").toString()));
      }
      if ((jsonObj.get("ueIpv4") != null && !jsonObj.get("ueIpv4").isJsonNull()) && !jsonObj.get("ueIpv4").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ueIpv4` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ueIpv4").toString()));
      }
      // validate the optional field `ueIpv6`
      if (jsonObj.get("ueIpv6") != null && !jsonObj.get("ueIpv6").isJsonNull()) {
        Ipv6Addr.validateJsonElement(jsonObj.get("ueIpv6"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PcscfRestorationRequestData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PcscfRestorationRequestData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PcscfRestorationRequestData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PcscfRestorationRequestData.class));

       return (TypeAdapter<T>) new TypeAdapter<PcscfRestorationRequestData>() {
           @Override
           public void write(JsonWriter out, PcscfRestorationRequestData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public PcscfRestorationRequestData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             PcscfRestorationRequestData instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of PcscfRestorationRequestData given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of PcscfRestorationRequestData
  * @throws IOException if the JSON string is invalid with respect to PcscfRestorationRequestData
  */
  public static PcscfRestorationRequestData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PcscfRestorationRequestData.class);
  }

 /**
  * Convert an instance of PcscfRestorationRequestData to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

